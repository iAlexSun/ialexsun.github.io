<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iAlexSun&#39;s</title>
  <subtitle>Keep Heart</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-22T07:02:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iAlexSun</name>
    <email>s649605510@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CoreML and Vision 入门学习</title>
    <link href="http://yoursite.com/2017/06/21/CoreML%20and%20Vision/"/>
    <id>http://yoursite.com/2017/06/21/CoreML and Vision/</id>
    <published>2017-06-21T03:53:27.000Z</published>
    <updated>2017-06-22T07:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年的WWDC大会应该是近几年中有比较大动作的一次开发者大会，因为在最新的操作系统iOS11 SDK中增加了几个十分有重量的框架。主要是针对目前前沿科技研发的机器学习的库CoreML,Vision,ARKit。之前Apple一直在研究ML(Machine Learning)方面的的研究，只是在这次开发者大会上大大降低了开发者接入的门槛，这次算是为WWDC做一次笔记吧。<br><a id="more"></a></p>
<h2 id="1-CoreML介绍"><a href="#1-CoreML介绍" class="headerlink" title="1.CoreML介绍"></a>1.CoreML介绍</h2><p>自己动手写的一个WWDC中演示的实时对物体检测的Demo:<a href="https://github.com/iAlexSun/MySampleCode/tree/master/CMCoreMLDetect" target="_blank" rel="external">CMCoreMLDetect</a></p>
<p><img src="http://ac-mcm5vzvc.clouddn.com/5037428b2a248e15243c.gif" alt=""></p>
<p>CoreML(Core Machine Learning)是Apple在2017年WWDC推出十分重要的框架之一。CoreML接入是十分容易的，下面介绍一下如何接入我们的APP。我们可以<a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">下载</a>一个训练好的模型然后拖入到我们的APP中即可使用。<br><img src="http://ac-mcm5vzvc.clouddn.com/462eff3922d1f63480f4.png" alt=""><br><img src="http://ac-mcm5vzvc.clouddn.com/fc1f43b122fd4d9c3980.png" alt=""><br>Xcode会帮助我们自动生成对应的代码。文件名称就是模型的名字。使用的时候我们可以通过如下代码进行调用模型中的方法就可以对静态图片进行识别操作了，但是很多时候对静态图片的识别不能满足我们场景的需求。需要WWDC中介绍的对物体进行实时的物体扫描操作，检测物体。</p>
<p>对模型的加载可进行图片的处理和识别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">guard let model = try? VNCoreMLModel(for: GoogLeNetPlaces().model) else &#123;</span><br><span class="line">      fatalError(&quot;Couldn&apos;t init model&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    let request = VNCoreMLRequest(model: model, completionHandler: ResultsMethod)</span><br><span class="line">    let pixelBuffer = image.convertToPixelBuffer(image: image, imageFrame: 299.0)</span><br><span class="line">    let handler = VNImageRequestHandler(cvPixelBuffer:pixelBuffer!, options: [:])</span><br><span class="line">       </span><br><span class="line"> guard ((try? handler.perform([request])) != nil) else &#123;</span><br><span class="line">           fatalError(&quot;Error on model&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如下代码是针对CoreML需要的图片格式进行处理封装的一个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func convertToPixelBuffer(image:UIImage,imageFrame:CGFloat) -&gt; CVPixelBuffer? &#123;</span><br><span class="line">        var pixelBuffer : CVPixelBuffer?</span><br><span class="line">        let imageDimension : CGFloat = imageFrame</span><br><span class="line">        let rgbColorSpace = CGColorSpaceCreateDeviceRGB()</span><br><span class="line">        let imageSize = CGSize(width:imageDimension, height:imageDimension)</span><br><span class="line">        let imageRect = CGRect(origin: CGPoint(x:0, y:0), size: imageSize)</span><br><span class="line">        </span><br><span class="line">        let options = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue,</span><br><span class="line">                       kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionary</span><br><span class="line">        </span><br><span class="line">        UIGraphicsBeginImageContextWithOptions(imageSize, true, 1.0)</span><br><span class="line">        image.draw(in:imageRect)</span><br><span class="line">        guard let newImage = UIGraphicsGetImageFromCurrentImageContext() else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        UIGraphicsEndImageContext()</span><br><span class="line">        let status = CVPixelBufferCreate(kCFAllocatorDefault,</span><br><span class="line">                                         Int(newImage.size.width),</span><br><span class="line">                                         Int(newImage.size.height),</span><br><span class="line">                                         kCVPixelFormatType_32ARGB,</span><br><span class="line">                                         options,</span><br><span class="line">                                         &amp;pixelBuffer)</span><br><span class="line">        guard (status == kCVReturnSuccess),</span><br><span class="line">            let uwPixelBuffer = pixelBuffer else &#123;</span><br><span class="line">                return nil</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CVPixelBufferLockBaseAddress(uwPixelBuffer,</span><br><span class="line">                                     CVPixelBufferLockFlags(rawValue: 0))</span><br><span class="line">        let pixelData = CVPixelBufferGetBaseAddress(uwPixelBuffer)</span><br><span class="line">        let context = CGContext(data: pixelData,</span><br><span class="line">                                width: Int(newImage.size.width),</span><br><span class="line">                                height: Int(newImage.size.height),</span><br><span class="line">                                bitsPerComponent: 8,</span><br><span class="line">                                bytesPerRow: CVPixelBufferGetBytesPerRow(uwPixelBuffer),</span><br><span class="line">                                space: rgbColorSpace,</span><br><span class="line">                                bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue)</span><br><span class="line">        guard let uwContext = context else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uwContext.translateBy(x: 0, y: newImage.size.height)</span><br><span class="line">        uwContext.scaleBy(x: 1.0, y: -1.0)</span><br><span class="line">        </span><br><span class="line">        UIGraphicsPushContext(uwContext)</span><br><span class="line">        newImage.draw(in: CGRect(x: 0,</span><br><span class="line">                                 y: 0,</span><br><span class="line">                                 width: newImage.size.width,</span><br><span class="line">                                 height: newImage.size.height))</span><br><span class="line">        UIGraphicsPopContext()</span><br><span class="line">        CVPixelBufferUnlockBaseAddress(uwPixelBuffer, CVPixelBufferLockFlags(rawValue: 0))</span><br><span class="line">        return pixelBuffer</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ac-mcm5vzvc.clouddn.com/3afddca5695270716da6.png" alt=""><br>其实目前来说对静态图片的检测就是这么简单的就可以实现了。</p>
<ul>
<li>第一步:将需要的<a href="https://developer.apple.com/machine-learning/" target="_blank" rel="external">模型下载</a>后拖入程序中。<br><img src="http://ac-mcm5vzvc.clouddn.com/56cb012d2998750cc73a.png" alt=""></li>
<li>第二步:对所需要检测的图片进行格式处理和转换。<br><img src="http://ac-mcm5vzvc.clouddn.com/432bd8a26f5429105463.png" alt=""></li>
<li>第三步:调用模型中的一些方法进行最后的图片检测,但是这只是其中最简单的需求部分，就如上文所说的可能我们使用的场景不会这样的简单，比如实时检测。<br><img src="http://ac-mcm5vzvc.clouddn.com/df3716756661407117f2.png" alt=""><h2 id="2-物体实时识别"><a href="#2-物体实时识别" class="headerlink" title="2.物体实时识别"></a>2.物体实时识别</h2>实时监测主要是开启摄像头然后获取每一帧图像然后进行相对应的格式进行转换然后再次进行图片的处理和识别基本的情况是这样。但是如果处理不得当会产生UI卡顿的的情况CPU飞起的情况。那么开启摄像头的主要代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func openCamera()&#123;</span><br><span class="line">       captureSession.sessionPreset = AVCaptureSession.Preset.high</span><br><span class="line">       let devices = AVCaptureDevice.devices()</span><br><span class="line">       for device in devices &#123;</span><br><span class="line">           if (device.hasMediaType(AVMediaType.video)) &#123;</span><br><span class="line">               if (device.position == .back) &#123;</span><br><span class="line">                   cameraDevice = device</span><br><span class="line">                   if cameraDevice != nil &#123;</span><br><span class="line">                       beginSession()</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func beginSession()&#123;</span><br><span class="line">       </span><br><span class="line">       let err : NSError? = nil</span><br><span class="line">       let captureDeviceInput = try? AVCaptureDeviceInput.init(device: cameraDevice)</span><br><span class="line">       captureSession.addInput(captureDeviceInput!)</span><br><span class="line">       let output = AVCaptureVideoDataOutput()</span><br><span class="line">       let cameraQueue = DispatchQueue(label:&quot;com.CoreMLDetect.cameraQueue&quot;)</span><br><span class="line">       output.setSampleBufferDelegate(self, queue:cameraQueue)</span><br><span class="line">       output.videoSettings = [kCVPixelBufferPixelFormatTypeKey as String: kCVPixelFormatType_32BGRA]</span><br><span class="line">       captureSession.addOutput(output)</span><br><span class="line">       if err != nil &#123;</span><br><span class="line">           print(&quot;error: \(String(describing: err?.localizedDescription))&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)</span><br><span class="line">       previewLayer.videoGravity = AVLayerVideoGravity.resizeAspectFill</span><br><span class="line">       previewLayer.frame = self.view.bounds</span><br><span class="line">       self.view.layer.addSublayer(previewLayer)</span><br><span class="line">       captureSession.startRunning()</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>那么我们需要就是接收图像，在开启摄像头之后会有一个代理方法进行接收每一帧图像，在这个代理方法里面我们应该使用多线程处理图片防止CPU飞起主要代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer)</span><br><span class="line">       let cameraImage = CIImage(cvPixelBuffer: pixelBuffer!)</span><br><span class="line">       let image = UIImage(ciImage: cameraImage)</span><br><span class="line">       let result = MLDetectImageModel(image: image)</span><br><span class="line">       VNDetectImageModel(image:image)</span><br><span class="line">       DispatchQueue.global().async &#123;</span><br><span class="line">           DispatchQueue.main.async &#123;</span><br><span class="line">               self.resultLabel.text = String.init(format:&quot;Inceptionv3:%@ %.2f&quot;, result.classLabel,result.classLabelProb)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>基本上CoreML可以实现的入门Demo基本就告一段落了，目前来说CoreML没有被完全开发出来，iOS开发者能做到的也就是基本可以将训练好的模型带入到项目中进行后期的训练好的数据进行识别。在手机和其他设备上基本不会出现在线训练的情况的，目前对于机器学习训练模型是十分依赖硬件的，所以我们还是希望等待Apple后期如何出现更好的玩转机器学习这盘棋。</p>
<hr>
<h2 id="感想和猜想"><a href="#感想和猜想" class="headerlink" title="感想和猜想"></a>感想和猜想</h2><p>目前移动端开发工程师基本能做的很少，虽然目前Apple将门槛降低了很多，但是我们也只能做到很微弱的一部分，但是未来绘出现什么样的其他情况我们也不得而知，但是很希望CoreML会强大做到很优秀的程度。下面这个图片是我现在的想法。<br><img src="http://ac-mcm5vzvc.clouddn.com/149e0a56fec6416bf4a0.png" alt=""><br>未来如果可以动态加载模型进行动态的调用模型方法就可以大大减少项目的大小，目前来说一个普通级别的商业项目如果包含一个大一点的模型会多出500M左右，这个用户可能就不回很接受。所以未来可能有两个方向是需要改进的。第一个可能是可以在手机上动态训练模型，边训练边增强模型的准确度。第二个可能是动态将训练好的模型下载到APP中，其中有一个功能可以开启和模型相关的如果开启再下载就可以了，这样可以减少用户下载应用的烦恼。以上纯属作者自己YY。PS:图片部分来自<a href="https://devstreaming-cdn.apple.com/videos/wwdc/2017/710vxa4hl8hyb72/710/710_core_ml_in_depth.pdf" target="_blank" rel="external">WWDC</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年的WWDC大会应该是近几年中有比较大动作的一次开发者大会，因为在最新的操作系统iOS11 SDK中增加了几个十分有重量的框架。主要是针对目前前沿科技研发的机器学习的库CoreML,Vision,ARKit。之前Apple一直在研究ML(Machine Learning)方面的的研究，只是在这次开发者大会上大大降低了开发者接入的门槛，这次算是为WWDC做一次笔记吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS的人脸检测 -- CoreImage与OpenCV(一)</title>
    <link href="http://yoursite.com/2017/04/06/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2017/04/06/人脸检测/</id>
    <published>2017-04-06T08:48:27.000Z</published>
    <updated>2017-05-03T15:26:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道今年的热点是人工智能,那就蹭一次热点。由于最近公司需要做人脸识别的项目,得知要做人脸识别这个东西先是一脸懵逼,接着内心又有些小激动。懵逼是因为之前压根没有做过这类东西,完全不知道从何下手.激动就是没接触过这么比较”智能”的东西,感觉做起来会很难但是应该会很好玩吧。很早之前就有这样的技术,只是最近火了一把,然后争相追捧。</p>
<a id="more"></a>
<h2 id="人脸检测介绍"><a href="#人脸检测介绍" class="headerlink" title="人脸检测介绍"></a>人脸检测介绍</h2><p><img src="http://ac-mcm5vzvc.clouddn.com/b17f7014f24e014222f1.png" alt=""> </p>
<p>首先要说<code>人脸检测</code>和<code>人脸识别</code>不是一个东西,绝对会有人弄混,刚开始我也弄混了。<code>人脸识别</code>先要用<code>检测人脸</code>，因为组里安卓使用的OpenCV加人脸算法实现的人脸检测,又是一脸懵逼OpenCV是什么？抱着激动的心情去网上寻找资料,OpenCV的资料真是很少,配置环境就我就配置了2天。今天我们主要介绍一下iOS原生API<code>Core Image</code>,为什么可以使用<code>Core Image</code>实现<code>人脸检测</code>呢?这要追溯到<code>iOS 5</code>,Apple在<code>Core Image</code>中添加了<code>人脸检测</code>的技术,只是大家一直没有发现,iPhone自带的相机就有<code>人脸检测</code>功能，最近比较火的<code>iOS的脸萌</code>我猜测也会部分使用<code>Core Image</code>中的一些技术吧。下面我们详细介绍一些<code>Core Image</code>吧！</p>
<h2 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h2><p><code>Core Image</code>框架是iOS中一个重要的处理图像的框架，它能处理来自于Core Graphics、Core Video、Image I/O等框架的数据类型，并通过CPU或者GPU进行渲染。人脸检测使用到了<code>CIDetector</code>,这个类可以实现静态图片人脸的位置,鼻子，嘴，都会获取到。</p>
<p><img src="http://ac-mcm5vzvc.clouddn.com/3ca0f5bf7ce183660f05.gif" alt=""></p>
<p>上图使用了<code>CIDetector</code>中的方法实现了<code>人脸检测</code>并且进行了<code>人脸标记</code>,<code>人脸裁剪</code>。我们下面看看如何一步步实现的<code>人脸检测</code>。</p>
<h2 id="人脸检测实现"><a href="#人脸检测实现" class="headerlink" title="人脸检测实现"></a>人脸检测实现</h2><p>其实使用静态图片人脸检测十分简单,代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**创建CIContext：CIContext有两种方式初始化，分别对应着GPU和CPU</span><br><span class="line">创建基于GPU的CIContext对象: context = [CIContext contextWithOptions:nil];</span><br><span class="line">创建基于CPU的CIContext对象: context = [CIContext contextWithOptions:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextSoftwareRender]];</span><br><span class="line">一般情况使用的是第一种，即基于GPU的方式，因为效率会比CPI的高很多。但是使用基于GPU的CIContext对象无法跨应用访问。例如使用UIImagePickerController选取图片美化，如果直接在其代理方法种使用CIContext对象进行处理，那么系统会自动将其降到为基于CPU的。所以，一般是在其代理方法中获取到图片，然后在主类中再来美化图片</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">CIContext * context = [CIContext contextWithOptions:nil];</span><br><span class="line"></span><br><span class="line">//获取到当前图片</span><br><span class="line">UIImage * imageInput = [_inputImgView image];  </span><br><span class="line"></span><br><span class="line">//将图片转换为CIImage</span><br><span class="line">CIImage * image = [CIImage imageWithCGImage:imageInput.CGImage]; </span><br><span class="line"></span><br><span class="line">//设置CIDetector性能消耗</span><br><span class="line">NSDictionary * param = [NSDictionary dictionaryWithObject:CIDetectorAccuracyHigh forKey:CIDetectorAccuracy];</span><br><span class="line"></span><br><span class="line">//创建脸部特征对象</span><br><span class="line">CIDetector * faceDetector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:param];</span><br><span class="line"></span><br><span class="line">//通过脸部特征对象可以通过图片获得一个脸部特征的数组,里面会有脸,鼻子,嘴巴的位置信息。</span><br><span class="line">NSArray * detectResult = [faceDetector featuresInImage:image];</span><br></pre></td></tr></table></figure>
<p>人脸的位置标注核心部分代码我们使用如下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">for (CIFaceFeature * faceFeature in detectResult) &#123;</span><br><span class="line"></span><br><span class="line">//将脸部位置使用方框绘制出来</span><br><span class="line">       UIView *faceView = [[UIView alloc] initWithFrame:faceFeature.bounds];</span><br><span class="line">       faceView.layer.borderColor = [UIColor redColor].CGColor;</span><br><span class="line">       faceView.layer.borderWidth = 1;</span><br><span class="line">       [resultView addSubview:faceView];</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">//将左眼睛位置使用方框绘制出来</span><br><span class="line">       if (faceFeature.hasLeftEyePosition) &#123;</span><br><span class="line">           UIView * leftEyeView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 5, 5)];</span><br><span class="line">           [leftEyeView setCenter:faceFeature.leftEyePosition];</span><br><span class="line">           leftEyeView.layer.borderWidth = 1;</span><br><span class="line">           leftEyeView.layer.borderColor = [UIColor redColor].CGColor;</span><br><span class="line">           [resultView addSubview:leftEyeView];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">//将右眼睛位置使用方框绘制出来      </span><br><span class="line">       if (faceFeature.hasRightEyePosition) &#123;</span><br><span class="line">           UIView * rightEyeView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 5, 5)];</span><br><span class="line">           [rightEyeView setCenter:faceFeature.rightEyePosition];</span><br><span class="line">           rightEyeView.layer.borderWidth = 1;</span><br><span class="line">           rightEyeView.layer.borderColor = [UIColor redColor].CGColor;</span><br><span class="line">           [resultView addSubview:rightEyeView];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">//将嘴巴位置使用方框绘制出来    </span><br><span class="line">       if (faceFeature.hasMouthPosition) &#123;</span><br><span class="line">           UIView * mouthView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 5)];</span><br><span class="line">           [mouthView setCenter:faceFeature.mouthPosition];</span><br><span class="line">           mouthView.layer.borderWidth = 1;</span><br><span class="line">           mouthView.layer.borderColor = [UIColor redColor].CGColor;</span><br><span class="line">           [resultView addSubview:mouthView];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   [resultView setTransform:CGAffineTransformMakeScale(1, -1)];</span><br></pre></td></tr></table></figure>
<p>接下来进行图片截取我们使用CGImageRef进行图片截取:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//原图片</span><br><span class="line">UIImage * img = [UIImage imageNamed:@&quot;11.11.52.png&quot;];</span><br><span class="line"></span><br><span class="line">//转化为位图</span><br><span class="line">CGImageRef temImg = img.CGImage;</span><br><span class="line"></span><br><span class="line">//根据范围截图</span><br><span class="line">temImg=CGImageCreateWithImageInRect(temImg, CGRectMake(0, 0, 100, 100));</span><br><span class="line"></span><br><span class="line">//得到新的图片</span><br><span class="line">UIImage *new = [UIImage imageWithCGImage:temImg];</span><br><span class="line"></span><br><span class="line">//释放位图对象</span><br><span class="line">CGImageRelease(temImg);</span><br><span class="line"></span><br><span class="line">注意：最后必须要调用这个函数，否则会造成内存泄露</span><br><span class="line">CGImageRelease(temImg)</span><br></pre></td></tr></table></figure>
<p>以上就是静态图片人脸识别和截取方法,但是我们的需求是动态检测和识别,这就是有区别的了,但是以上这些代码是实现人脸识别的基础一定要了解才会进一步去实现实时动态检测。近期会推出实时动态检测，因为最近比较忙。</p>
<hr>
<p>Demo地址:<a href="https://github.com/iAlexSun/MySampleCode" target="_blank" rel="external">https://github.com/iAlexSun/MySampleCode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家都知道今年的热点是人工智能,那就蹭一次热点。由于最近公司需要做人脸识别的项目,得知要做人脸识别这个东西先是一脸懵逼,接着内心又有些小激动。懵逼是因为之前压根没有做过这类东西,完全不知道从何下手.激动就是没接触过这么比较”智能”的东西,感觉做起来会很难但是应该会很好玩吧。很早之前就有这样的技术,只是最近火了一把,然后争相追捧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>仿写Keep登录页视频播放</title>
    <link href="http://yoursite.com/2017/01/18/%E4%BB%BF%E5%86%99Keep%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/01/18/仿写Keep登录页/</id>
    <published>2017-01-18T12:18:27.000Z</published>
    <updated>2017-03-19T14:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>有好多人使用过Keep来做运动,但是作为一个程序猿第一眼就被登录页的设计吸引住了，吸引原来是一个持续播放的视频在登录页。虽然有很多App早就实现了,但是笔者一直没有时间自己实现这个功能，后期笔者简单实现了一个可以循环播放视频的Demo。</p>
<a id="more"></a>
<hr>
<p>大家可以看一下效果图如下:</p>
<p><img src="http://ac-mcm5vzvc.clouddn.com/9850b193013417ca04fd.gif" alt=""></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>iOS9之前，iOS播放视频文件一般使用 MPMoviePlayerViewController。其实实现方式非常容易就是想使用上述方式。</p>
<ul>
<li>要包含#import头文件和MediaPlayer.framework。</li>
<li>应该准备一个视频文件,文件尽量小一些,最好为mp4格式(文件太太占用App的太多影响用户体验)。</li>
<li>一个存储视频的Plist文件方便后面加载.<br><img src="http://ac-mcm5vzvc.clouddn.com/9588ec9f1b0bdc928140.png" alt=""></li>
</ul>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>首先我们应该讲视频文件中对应的信息都取出来放在对应的Model中,如果后面我们需要更改视频或者不循环播放等方式都可以直接修改Plist文件不修改任何代码,是不是很爽的样子。</p>
<ul>
<li>我们创建一个Model来存储对应信息.我们将信息取出来后,实现他们对应的类方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+(NSDictionary *)getUrlInfo;</span><br><span class="line">+(NSString *)getVideoUrl;</span><br><span class="line">+(NSString *)getVideoType;</span><br><span class="line">+(BOOL)getLoopMode;</span><br></pre></td></tr></table></figure>
<p><img src="http://ac-mcm5vzvc.clouddn.com/6895be146d70d3a027fa.png" alt=""></p>
<p>到了最关键的一步就是加载这些文件,在最开始判断是否能够加载到这个视频的信息。</p>
<ul>
<li>如果有这个视频信息，就准备加载.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> -(void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    if ([STLVideoFunctions getUrlInfo] != nil) &#123;</span><br><span class="line">        self.isLoop = [STLVideoFunctions getLoopMode];</span><br><span class="line">        </span><br><span class="line">        [self preparePlayback];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加载视频和设置一些播放视频的属性添加到UIView上:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)preparePlayback &#123;</span><br><span class="line">    if (self.player == nil) &#123;</span><br><span class="line">        NSURL *url = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:[STLVideoFunctions getVideoUrl] ofType:[STLVideoFunctions getVideoType]]];</span><br><span class="line">        </span><br><span class="line">        self.player = [[MPMoviePlayerController alloc] initWithContentURL:url];</span><br><span class="line">        [self.player setControlStyle:MPMovieControlStyleNone];</span><br><span class="line">        [self.player prepareToPlay];</span><br><span class="line">        [self.player.view setFrame:self.view.frame];</span><br><span class="line">        [self.view addSubview:self.player.view];</span><br><span class="line">        [self.view sendSubviewToBack:self.player.view];</span><br><span class="line">        self.player.scalingMode = MPMovieScalingModeAspectFill;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在出现之前发送通知就是控制视频播放和一些控制播放方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line"></span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    [self getPlayerNotifications];</span><br><span class="line">    </span><br><span class="line">    [self.player play];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送通知改变播放方式</span><br><span class="line">- (void)getPlayerNotifications &#123;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(moviePlayerStateChangeNotification:) name:MPMoviePlayerPlaybackStateDidChangeNotification object:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)moviePlayerStateChangeNotification:(NSNotification *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    MPMoviePlayerController *moviePlayer = notification.object;</span><br><span class="line">    MPMoviePlaybackState playbackState = moviePlayer.playbackState;</span><br><span class="line">    </span><br><span class="line">    switch (playbackState) &#123;</span><br><span class="line">        case MPMoviePlaybackStatePaused:</span><br><span class="line">        case MPMoviePlaybackStateStopped:</span><br><span class="line">        case MPMoviePlaybackStateInterrupted:&#123;</span><br><span class="line">            </span><br><span class="line">            if (self.isLoop) &#123;</span><br><span class="line">                moviePlayer.controlStyle = MPMovieControlStyleNone;</span><br><span class="line">                [self.player play];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在视图消失后视频暂停播放，移除通知即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line"></span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:MPMoviePlayerPlaybackStateDidChangeNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line"></span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    [self.player pause];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>一个仿照Keep登录页的实现思路大概就是这样，非常的简单。</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://github.com/iAlexSun/MySampleCode.git" target="_blank" rel="external">GitHub: https://github.com/iAlexSun/MySampleCode.git</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有好多人使用过Keep来做运动,但是作为一个程序猿第一眼就被登录页的设计吸引住了，吸引原来是一个持续播放的视频在登录页。虽然有很多App早就实现了,但是笔者一直没有时间自己实现这个功能，后期笔者简单实现了一个可以循环播放视频的Demo。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入浅出了解Runloop</title>
    <link href="http://yoursite.com/2016/07/24/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BA%86%E8%A7%A3Runloop/"/>
    <id>http://yoursite.com/2016/07/24/深入浅出了解Runloop/</id>
    <published>2016-07-24T02:38:27.000Z</published>
    <updated>2017-03-19T14:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在学习关于Runloop的知识,由浅入深的学习了一段时间,这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理.学习了大神的Runloop的讲解,有了一定的理解了Runloop,这个词在我的认知中不再只是一个简单的 “跑圈” 的程度,但是也不会理解的很透,日后有机会会更加深入学习关于底层知识的.</p>
<a id="more"></a>
<h1 id="Runloop基本概念"><a href="#Runloop基本概念" class="headerlink" title="Runloop基本概念"></a>Runloop基本概念</h1><p>很多人都知道Runloop浅显的意思 “跑圈” “循环”啊,如果深入一点的话就是用一个do while一个死循环来跑圈的,接下来就让我们看看Runloop是如何进行跑圈的吧！</p>
<ul>
<li><p>RunLoop的基本作用:</p>
<ul>
<li><p>保持程序的持续运行</p>
</li>
<li><p>处理APP中各种事件(比如:触摸事件,定时器事件，Selector事件等)</p>
</li>
<li>能节省CPU资源，提高程序的性能:该做事的时候就唤醒，没有事情就睡眠</li>
</ul>
</li>
</ul>
<h1 id="Runloop与多线程"><a href="#Runloop与多线程" class="headerlink" title="Runloop与多线程"></a>Runloop与多线程</h1><p>一般情况下一个线程只能执行一次任务后就会退出,我们不能让程序像命令行一样执行完命令就推出,我们都知道程序的main函数是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">  @autoreleasepool &#123;</span><br><span class="line">      return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认启动的Runloop是在<code>UIApplicationMain</code>函数内部启动与主线程相关联.</li>
<li><p>RunLoop在第一次获取时创建，在线程结束时销毁.</p>
</li>
<li><p>般情况下一个线程只对应一个Runloop,子线程的Runoop需要手动启动(调run方法).</p>
</li>
</ul>
<h2 id="RunLoop与对象"><a href="#RunLoop与对象" class="headerlink" title="RunLoop与对象"></a>RunLoop与对象</h2><ul>
<li><p>RunLoop实际上就是一个对象,来处理事件和消息,iOS中有两套API使用RunLoop</p>
<ul>
<li>Foundation框架中的<code>NSRunLoop</code>;</li>
<li>Core Foundation中的<code>CFRunLoopRef</code>;</li>
</ul>
</li>
<li><p><code>CFRunLoopRef</code> 是基于存C语言开发的API,<code>NSRunLoop</code>只是基于OC对<br><code>CFRunLoopRef</code> 进行的封装,所以我们这篇文章应该主要进行对<code>CFRunLoopRef</code> 深入研究,才能了解RunLoop的原理和执行.<code>CFRunLoopRef</code> 的代码是开源的，你可以下载源码<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">CFRunLoopRef</a>进行深入了解.<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">苹果官方文档</a></p>
</li>
<li><p>苹果不允许直接创建 RunLoop，官方提供了两个RunLoop获取函数(这里忽略 NSRunLoop的两个函数)- </p>
<ul>
<li>Core Foundation框架中<code>CFRunLoopGetCurrent()</code> <code>CFRunLoopGetMain()</code>可以进行测试发现,线程创建后不会有Runloop,当调用<code>CFRunLoopGetCurrent()</code>或<code>CFRunLoopGetMain()</code>函数时候才会第一次创建Runloop.</li>
</ul>
</li>
</ul>
<h1 id="Runloop的内部结构"><a href="#Runloop的内部结构" class="headerlink" title="Runloop的内部结构"></a>Runloop的内部结构</h1><p><img src="http://ac-mcm5vzvc.clouddn.com/7daf2abb34432dcc.png" alt=""><br>一个线程只能对应一个Runloop,可以有若干Mode,一个Mode可以若干个Timer/Observer/Source.每次只能进入一个Mode,这个Model叫做CurrentMode.如果想切换模式,一定要先退出当前Mode.</p>
<ul>
<li><p>系统默认注册了5中Mode:</p>
<ul>
<li><p><code>NSDefaultRunLoopMode</code>:默认的Mode，通常主线程的RunLoop是在这个Mode下运行</p>
<ul>
<li><p><code>UITrackingRunLoopMode</code>:界面跟踪Mode，当用户与界面交互的时候会在此Mode下运行</p>
</li>
<li><p><code>NSRunLoopCommonModes</code>:这个不是一种真正的Mode，是一个占位用的Mode</p>
</li>
<li><p>UIInitializationRunLoopMode:程序启动时的Mode，启动完成后就不在此Mode下</p>
</li>
<li>GSEventReceiveRunLoopMode:接受系统事件的内部Mode，一般我们用不到</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="关于Core-Foundation里面RunLoop-的类"><a href="#关于Core-Foundation里面RunLoop-的类" class="headerlink" title="关于Core Foundation里面RunLoop 的类"></a>关于Core Foundation里面RunLoop 的类</h2><ul>
<li><p>CFRunLoopModeRef:<br>CFRunLoopModeRef 类并没有对外暴露,只是通过 CFRunLoopRef 的接口进行了封装</p>
<ul>
<li>CFRunLoopSourceRef(事件源):Source有两个版本：Source0 和 Source1。</li>
<li><p>Source0:非基于Port的</p>
</li>
<li><p>Source1 基于Port的，通过内核和其他线程通信，接收、分发系统事件,这种 Source 能主动唤醒 RunLoop 的线程.    </p>
</li>
<li><p>CFRunLoopTimerRef(定时器):CFRunLoopTimerRef是基于时间的触发器,基本上说的就是NSTimer，它受RunLoop Mode的影响。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   // 创建一个定时器</span><br><span class="line">	 NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 		target:self selector:@selector(run) userInfo:nil 		repeats:YES];</span><br><span class="line">拽了界面上的某个控件(会切换成UITrackingRunLoopMode)</span><br><span class="line">  [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode];// NSDefaultRunLoopMode:NSTimer只有在默认模式下	(NSDefaultRunLoopMode)工作，切换到其他模式不再工作，比如拖</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  ·NSRunLoopCommonModes仅仅是标记NSTimer在两种模式(UITrackingRunLoopMode/NSDefaultRunLoopMode)下都能运行,但一个RunLoop中同一时间内只能运行一种模式.<code>UITrackingRunLoopMode</code>拖拽UI界面时出发定时器,在默认模式(NSDefaultRunLoopMode)下不工作</p>
<pre><code>- CFRunLoopObserverRef(观察者):可以通过CFRunLoopObserverRef来监听RunLoop状态的改变
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity)&#123;</span><br><span class="line">   kCFRunLoopEntry         = (1UL &lt;&lt; 0), //状态值:1 即将进入Loop</span><br><span class="line">   kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),//状态值:2 即将处理 Timer</span><br><span class="line">   kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),//状态值:4 即将处理Source</span><br><span class="line">   kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),//状态值:32 即将进入休眠        </span><br><span class="line">   kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),//状态值:64 刚从休眠中唤醒</span><br><span class="line">   kCFRunLoopExit          = (1UL &lt;&lt; 7),//状态值:128 即将退出Loop</span><br><span class="line">   kCFRunLoopAllActivities = 0x0FFFFFFFU // 表示监听上面所有的状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以通过以下代码测试RunLoop状态发生改变对应的状态值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverRef observer =CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">     NSLog(@&quot;----RunLoop状态发生改变---%zd&quot;, activity);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddObserver(CFRunLoopGetCurrent(),observer,</span><br><span class="line">kCFRunLoopDefaultMode);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRelease(observer); //观察者要手动释放</span><br></pre></td></tr></table></figure>
<p>上面是Mode中必须包含的元素,Source/Timer/Observer可以都有,也可以只有一个,如果一个都没有会直接退出Runloop状态,不进入循环。</p>
<h2 id="PS-看iOS线下分享Runloop深入了解的时候-大家讨论为什么状态为什么会没有3和4-是不是被官方干掉了！仅供娱乐-哪位了解到可以给我留言"><a href="#PS-看iOS线下分享Runloop深入了解的时候-大家讨论为什么状态为什么会没有3和4-是不是被官方干掉了！仅供娱乐-哪位了解到可以给我留言" class="headerlink" title="PS:看iOS线下分享Runloop深入了解的时候,大家讨论为什么状态为什么会没有3和4,是不是被官方干掉了！仅供娱乐,哪位了解到可以给我留言."></a>PS:看<a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">iOS线下分享Runloop深入了解</a>的时候,大家讨论为什么状态为什么会没有3和4,是不是被官方干掉了！仅供娱乐,哪位了解到可以给我留言.</h2><h1 id="Runloop处理顺序"><a href="#Runloop处理顺序" class="headerlink" title="Runloop处理顺序"></a>Runloop处理顺序</h1><p>官方提供:<br><img src="http://ac-mcm5vzvc.clouddn.com/4671e9e78cd86ee1.png" alt=""></p>
<p>网友提供(易于理解):<br><img src="http://ac-mcm5vzvc.clouddn.com/6d40150bdeb3e504.png" alt=""></p>
<p>上图是Runloop处理顺序,可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h1 id="Runloop实际应用"><a href="#Runloop实际应用" class="headerlink" title="Runloop实际应用"></a>Runloop实际应用</h1><ul>
<li>ImageView显示:图片刷新(假如界面要刷新N多图片(渲染)，此时用户拖拽UI控件就会出现卡的效果,可以通过RunLoop实现)</li>
</ul>
<pre><code>[self.myImageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;0&quot;] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode]];
</code></pre><ul>
<li>常驻线程:(让子线程不进入消亡状态,等待其他线程发来消息,子线程中加入RunLoop+Source/Timer/Observer)</li>
</ul>
<pre><code>[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];
[[NSRunLoop currentRunLoop] run];
</code></pre><ul>
<li>自动释放池:释放池在Runloop睡眠前等待唤醒前是释放一次,进入下一次Runloop循环的时候又创建一次.创建子线程外面要有一个大的Runloop包住.<ul>
<li>自动释放池的原理:实际上因为<code>AutoreleasePool</code>会调用<code>objc_autoreleasePoolPop ``objc_autoreleasePoolPush</code>方法。<a href="http://ialexsun.cn/2016/08/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--AutoreleasePool/" target="_blank" rel="external">自动释放池的原理深入了解</a></li>
</ul>
</li>
</ul>
<p>友情链接:<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在学习关于Runloop的知识,由浅入深的学习了一段时间,这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理.学习了大神的Runloop的讲解,有了一定的理解了Runloop,这个词在我的认知中不再只是一个简单的 “跑圈” 的程度,但是也不会理解的很透,日后有机会会更加深入学习关于底层知识的.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于GCD你应该知道的那点事</title>
    <link href="http://yoursite.com/2016/07/06/%E5%85%B3%E4%BA%8EGCD%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2016/07/06/关于GCD你应该知道的那点事/</id>
    <published>2016-07-06T02:38:27.000Z</published>
    <updated>2017-03-19T14:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要引入多线程？多线程的好处?GCD又是什么? NSThread已经属于古董级别的东西了，欣赏一下可以，真正使用就不要麻烦他了…</p>
<a id="more"></a>
<p>GCD是多线程中的新贵，比起NSThread更加强大，也更容易使用由于GCD的东西比较多，我会分好几篇文章介绍，这篇文章主要介绍GCD中的queue相关知识。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>一个应用程序开启一定会有一个进程,<code>必须</code>得有线程（每1个进程至少要有1条线程）.一个进程（程序）的所有任务都在线程中执行。</p>
</li>
<li><p>一个线程的任务是<code>串行</code>的,如果执行多个任务就要一个接着一个的按顺序的执行下去</p>
</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>如果开启多线程就会每条线程并行的执行任务,可以大大提高开发效率,比如可以同时开启3条线程同时下载3个文件.</p>
</li>
<li><p>同一个时间内CPU只能处理一个线程,只有一条线程在<code>执行</code>.那么为什么还会出现<code>并发</code>执行?因为CPU在快速的在多线程中快速的<code>调度</code>(切换),如果时间足够快那么就会造成多线程并发的假象。是不是线程越多就越好? </p>
</li>
<li><code>如果线程多到CPU切换不过来,CPU会非常消耗资源，CPU会累死，每条线程被调度到的频率大大降低,所以应该合理使用多线程</code>.  </li>
</ul>
<h1 id="ios程序中使用的多线程种类"><a href="#ios程序中使用的多线程种类" class="headerlink" title="ios程序中使用的多线程种类"></a>ios程序中使用的多线程种类</h1><ul>
<li>pthread:C语言,跨平台，复杂(使用较少).</li>
<li>NSThread:面向对象，程序员管理(使用较少).</li>
<li>GCD:利用CPU多核技术进行多线程开发(经常使用).</li>
<li><p>NSOperation:将同步与异步函数封装在内部(经常使用).</p>
<p><img src="http://ac-mcm5vzvc.clouddn.com/cd2caa657a209753.png" alt=""></p>
</li>
</ul>
<h1 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h1><p>GCD(Grand Central Dispatch)作为纯C语言一个处理多线程，提供非常多强大的函数,自从iOS4.0被引入后。GCD依然是目前Apple开发的一个官网推荐的多核编程的开发方法。GCD 是一个可以替代诸如 NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。</p>
<h1 id="GCD常用函数"><a href="#GCD常用函数" class="headerlink" title="GCD常用函数"></a>GCD常用函数</h1><ul>
<li><p>GCD分为异步函数,同步函数</p>
</li>
<li><p>异步函数(async):</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue(), ^&#123;</span><br><span class="line">    //something           </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t //可以自定义,也可以使用系统的队列</span><br><span class="line">dispatch_get_global_queue(0, 0)//全局队列 </span><br><span class="line">dispatch_get_main_queue()//主线程的主队列</span><br></pre></td></tr></table></figure>
<ul>
<li><p>异步函数 + 主队列：只在主线程中执行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1.获得主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">       </span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  NSLog(@&quot;dispatch_async(queue, ^&#123;  	         	</span><br><span class="line">     NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步函数 + 并发队列：可以同时开启多条线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.获得全局的并发队列</span><br><span class="line">dispatch_queue_t queue =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line"></span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (NSInteger i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">   for (NSInteger i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步函数 + 串行队列：会开启新的线程，但是任务是串行的，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">//dispatch_queue_t queue = dispatch_queue_create(&quot;com.ialexsun.cn.queue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>同步函数(sync):</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_queue_t queue(), ^&#123;</span><br><span class="line">//something           </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t //可以自定义,也可以使用系统的队列</span><br><span class="line">dispatch_get_global_queue(0, 0)//全局队列 </span><br><span class="line">dispatch_get_main_queue()//主线程的主队列</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同步函数 + 主队列：只在主线程中执行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1.获得主队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步函数 + 并发队列：不会开启新的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1.获得全局的并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步函数 + 串行队列：不会开启新的线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.ialexsun.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">// 2.将任务加入队列</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="异步函数和同步函数关系和区别"><a href="#异步函数和同步函数关系和区别" class="headerlink" title="异步函数和同步函数关系和区别:"></a>异步函数和同步函数关系和区别:</h2><p><img src="http://ac-mcm5vzvc.clouddn.com/0f4058fa7bf5cb96.png" alt=""></p>
<p>GCD函数基本使用,GCD内容比较多，由于最近事情比较多所以先列举以上几个函数,后期会持续更新关于GCD的问题.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要引入多线程？多线程的好处?GCD又是什么? NSThread已经属于古董级别的东西了，欣赏一下可以，真正使用就不要麻烦他了…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何使用CocoaPods添加第三方库</title>
    <link href="http://yoursite.com/2015/08/30/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9E%B6App%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2015/08/30/第一次上架App的坑/</id>
    <published>2015-08-30T02:38:27.000Z</published>
    <updated>2017-03-19T14:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开始时候不知道动态库会有很多坑,也可能操作姿势不对.这都不重要了，主要想记录一下如何使用CocoaPods添加第三方库.可以避免很多不必要的麻烦,第三方库更新也不用手动管理.</p>
<a id="more"></a>
<p>最近由于第一次上架App所以想记录一下走过的坑,首先说明一下CocoaPods很多人都会使用，从iOS 8开始可以引用动态库。</p>
<p>优点:方便,直接拖入操作简单<br>缺点:审核时候会产生各种奇葩的错误</p>
<p>CocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库都支持CocoaPods,CocoaPods是用Ruby实现的，要想使用它首先需要有Ruby的环境。</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>1.查看ruby环境，系统默认安装ruby环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure>
<p>默认在终端中出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://rubygems.org/</span><br></pre></td></tr></table></figure></p>
<p>2.配置环境移除现有 Ruby 默认源，使用国内淘宝的ruby镜像, 命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure></p>
<p>3.验证新源是否替换成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p>
<p>4.安装 CocoaPods(安装时间可能有些长，大小约700M左右)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure></p>
<p>注意：苹果系统升级 OS X EL Capitan 后安装改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install -n /usr/local/bin cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure></p>
<p>5.更新 gem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem update --system</span><br></pre></td></tr></table></figure></p>
<p>6.新建工程，并在终端用 cd 指令到文件夹内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search 第三方(如:AFNetworking,填写需要的第三方库)</span><br></pre></td></tr></table></figure></p>
<p>7.创建Podfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Podfile</span><br></pre></td></tr></table></figure></p>
<p>进入编写画面后按“i”进入编辑状态</p>
<p>编辑 Podfile 文件，并写入要添加的第三方库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform:ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 2.3.1&apos;&lt;-------第三方</span><br></pre></td></tr></table></figure></p>
<p>结束编写装状态按“esc”，“:wq”保存退出。这时回到项目中</p>
<p>8.安装第三方库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure></p>
<p>恭喜你可以成功使用第三方库了.</p>
<p>注意:安装成功后会出现你的项目结构多了XXX.xcworkspace等东西出来，以后使用XXX.xcworkspace进入项目中即可。</p>
<h1 id="可能遇到的错误提示及解决方法："><a href="#可能遇到的错误提示及解决方法：" class="headerlink" title="可能遇到的错误提示及解决方法："></a>可能遇到的错误提示及解决方法：</h1><p>Error 1：<br>Error fetching <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>:</p>
<p>bad response Not Found 404 (<a href="http://ruby.taobao.org/specs.4.8.gz" target="_blank" rel="external">http://ruby.taobao.org/specs.4.8.gz</a>)</p>
<p>解决方案：把安装流程中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a http://ruby.taobao.org/</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure></p>
<p>Error 2：<br>ERROR:  While executing gem … (Errno::EPERM)</p>
<p>Operation not permitted - /usr/bin/pod</p>
<p>解决方案：苹果系统升级 OS X EL Capitan 后会出现的插件错误，将安装流程(4) 安装 CocoaPods的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure></p>
<p>改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure></p>
<p>以上很多借鉴了很多大神的博客,只是把遇到的坑和写的不足的地方总结在一起,站在巨人肩膀上进步的更快</p>
<h2 id="PS-以下是自己引入动态库踩过得坑-如果各位遇到过可以借鉴以下："><a href="#PS-以下是自己引入动态库踩过得坑-如果各位遇到过可以借鉴以下：" class="headerlink" title="PS:以下是自己引入动态库踩过得坑,如果各位遇到过可以借鉴以下："></a>PS:以下是自己引入动态库踩过得坑,如果各位遇到过可以借鉴以下：</h2><p>引入动态库产生的App审核错误编码记录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR ITMS-90087: &quot;Unsupported Architecture.The executable for XX.app/Frameworks/XXX.Framework  contains unsupported architecture&apos;[x86_64, i386]&apos;.&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR ITMS-90125: &quot;The Binary is invalid. The encryption info in the LC_ENCRYPTION_INFO load command is either missing or invalid, or the binary is already encrypted. This binary does not seem to have been built with Apple&apos;s Linker.&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR ITMS-90209: &quot;Invalid segment Alignment. The App Binary at XXX.app/Frameworks/xxx.framework/XXX does not have proper segment alignment. Try rebuilding the app with the latest xcode version.&quot; (I am already using the latest version.)</span><br></pre></td></tr></table></figure>
<p>解决办法:在stackoverflow搜索的方法添加一段build phase在程序中可以解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line"># This script loops through the frameworks embedded in the application and</span><br><span class="line"># removes unused architectures.</span><br><span class="line">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class="line">do</span><br><span class="line">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class="line">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">for ARCH in $ARCHS</span><br><span class="line">do</span><br><span class="line">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class="line">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class="line">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class="line">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目开始时候不知道动态库会有很多坑,也可能操作姿势不对.这都不重要了，主要想记录一下如何使用CocoaPods添加第三方库.可以避免很多不必要的麻烦,第三方库更新也不用手动管理.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
