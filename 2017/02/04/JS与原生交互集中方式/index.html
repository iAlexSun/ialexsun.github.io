<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JS与原生交互几种方式 · iAlexSun's</title><meta name="description" content="JS与原生交互几种方式 - iAlexSun"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="iAlexSun's"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="http://ac-pqj923nc.clouddn.com/0aac0dce4f2eff61dbe0.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/iAlexSun" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JS与原生交互几种方式</h1><div class="post-info">Feb 4, 2017</div><div class="post-content"><p>最近学习JS与原生交互发现一片新大陆,确切的说是WebView与JS交互在开发。发现有以下几种方法OC端与JS的交互大致有这几种：拦截协议、JavaScriptCore库、WKWebView、自定义NSURLProtocol拦截、WebViewJavascriptBridge。今天主要讲讲JavaScriptCore库的与OC端的交互。</p>
<a id="more"></a>
<h1 id="1-JavaScriptCore"><a href="#1-JavaScriptCore" class="headerlink" title="1.JavaScriptCore"></a>1.JavaScriptCore</h1><p>JavaScriptCore一个iOS7引进的标准库，iOS7以前也有开发者自行导入使用。Web端也比较容易统一，JavaScriptCore可以理解为一个浏览器的运行内核，使用JavaScriptCore可以使用native代码（这里主要指objectiveC和swift）与js代码进行相互的调用，本文主要从几个方面进行了解。</p>
<ul>
<li>native调用js代码</li>
<li>js调用native代码</li>
<li>异常处理</li>
<li>JavaScriptCore和webView的结合使用</li>
</ul>
<p>要使用JavaScriptCore，首先我们需要引入它的头文件 <code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</code></p>
<p>这个头里面引入了几个重要的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;JSContext.h&quot;</span><br><span class="line">#import &quot;JSValue.h&quot;</span><br><span class="line">#import &quot;JSManagedValue.h&quot;</span><br><span class="line">#import &quot;JSVirtualMachine.h&quot;</span><br><span class="line">#import &quot;JSExport.h&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口</li>
<li>JSValue是JSContext执行后的返回结果，他可以是任何js类型（比如基本数据类型和函数类型，对象类型等），并且都有对象的方法转换为native对象。</li>
<li>JSManagedValue是JSValue的封装，用它可以解决js和原声代码之间循环引用的问题</li>
<li>JSVirtualMachine 管理JS运行时和管理js暴露的native对象的内存</li>
<li>JSExport是一个协议，通过实现它可以完成把一个native对象暴漏给js</li>
</ul>
<h1 id="native调用js代码"><a href="#native调用js代码" class="headerlink" title="native调用js代码"></a>native调用js代码</h1><p>在JavaScriptCore中提供的调用JS的方法<code>- (JSValue *)evaluateScript:(NSString *)script;</code>方法就可以执行一段JavaScript脚本，并且如果其中有方法、变量等信息都会被存储在其中以便在需要的时候使用。JSValue提供了<code>- (JSValue *)callWithArguments:(NSArray *)arguments;</code>方法可以反过来将参数传进去来调用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 一个JSContext对象，就类似于Js中的window，</span><br><span class="line"> // 只需要创建一次即可。</span><br><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">// 执行一段js</span><br><span class="line">[context evaluateScript:@&quot;function add(a, b) &#123; return a + b; &#125;&quot;];</span><br><span class="line">// 根据下标取出方法</span><br><span class="line">JSValue *add = context[@&quot;add&quot;];</span><br><span class="line">NSLog(@&quot;Func: %@&quot;, add);</span><br><span class="line">// 传入参数 调用取到的方法</span><br><span class="line">JSValue *sum = [add callWithArguments:@[@(7), @(21)]];</span><br><span class="line">NSLog(@&quot;Sum: %d&quot;,[sum toInt32]);</span><br><span class="line">//OutPut:</span><br><span class="line">// Func: function add(a, b) &#123; return a + b; &#125;</span><br><span class="line">// Sum: 28</span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.jsContext = [[JSContext alloc] init];</span><br><span class="line"></span><br><span class="line">[self.jsContext evaluateScript:@&quot;var num = 10&quot;];</span><br><span class="line">[self.jsContext evaluateScript:@&quot;var squareFunc = function(value) &#123; return value * 2 &#125;&quot;];</span><br><span class="line">// 调用 计算面积</span><br><span class="line">JSValue *square = [self.jsContext evaluateScript:@&quot;squareFunc(num)&quot;];</span><br><span class="line"></span><br><span class="line">// 可以通过下标的方式获取到方法</span><br><span class="line">JSValue *squareFunc = self.jsContext[@&quot;squareFunc&quot;];</span><br><span class="line">// 传入参数 调用取到的方法</span><br><span class="line">JSValue *value = [squareFunc callWithArguments:@[@&quot;20&quot;]];</span><br><span class="line">NSLog(@&quot;%@&quot;, square.toNumber);</span><br><span class="line">NSLog(@&quot;%@&quot;, value.toNumber);</span><br></pre></td></tr></table></figure>
<h2 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h2><p>使用JavaScriptCore进行原生与js的交互主要是2种方式，block和注入模型使用协议代理。</p>
<ul>
<li>Block方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">// 定义一个block</span><br><span class="line">context[@&quot;log&quot;] = ^() &#123;</span><br><span class="line">  NSLog(@&quot;+++++++Begin Log+++++++&quot;);  </span><br><span class="line"></span><br><span class="line">  NSArray *args = [JSContext currentArguments];</span><br><span class="line">  for (JSValue *jsVal in args) &#123;</span><br><span class="line">   NSLog(@&quot;%@&quot;, jsVal);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  JSValue *this = [JSContext currentThis];</span><br><span class="line">  NSLog(@&quot;this: %@&quot;,this);</span><br><span class="line">  NSLog(@&quot;-------End Log-------&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">// 调用js执行log方法</span><br><span class="line"> [context evaluateScript:@&quot;log(&apos;ider&apos;, [7, 21],     </span><br><span class="line"> &#123; hello:&apos;world&apos;, js:100 &#125;);&quot;];</span><br></pre></td></tr></table></figure>
<p>当web端调用log方法，传入相关参数，就能调用OC端的block。实现交互。</p>
<p>通过注入模型的方式交互</p>
<p>首先，我们自定义一个协议，而且这个协议必须要遵守JSExport协议<br>协议暴露的方法，是供JS调用的方法。还可以实现回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@protocol JavaScriptObjectiveCDelegate &lt;JSExport&gt;</span><br><span class="line"></span><br><span class="line">// JS调用此方法来调用OC的相机</span><br><span class="line">- (void)callSystemCamera;</span><br><span class="line"></span><br><span class="line">// 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2)</span><br><span class="line">// 这里是只两个参数的。</span><br><span class="line">- (void)showAlert:(NSString *)title msg:(NSString *)msg;</span><br><span class="line"></span><br><span class="line">// 通过JSON传过来</span><br><span class="line">- (void)callWithDict:(NSDictionary *)params;</span><br><span class="line">// JS调用Oc，然后在OC中通过调用JS方法来传值给JS。</span><br><span class="line">- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接下来，我们还需要定义一个模型：</p>
<p>// 此模型用于注入JS的模型，这样就可以通过模型来调用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface HYBJsObjCModel : NSObject &lt;JavaScriptObjectiveCDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) JSContext *jsContext;</span><br><span class="line">@property (nonatomic, weak) UIWebView *webView;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>模型的实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@implementation HYBJsObjCModel</span><br><span class="line"></span><br><span class="line">- (void)callWithDict:(NSDictionary *)params &#123;</span><br><span class="line"> NSLog(@&quot;Js调用了OC的方法，参数为：%@&quot;, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JS调用了callSystemCamera</span><br><span class="line">- (void)callSystemCamera &#123;</span><br><span class="line"> NSLog(@&quot;JS调用了OC的方法，调起系统相册&quot;);</span><br><span class="line"></span><br><span class="line"> // JS调用后OC后，可以传一个回调方法的参数，进行回调JS</span><br><span class="line"> JSValue *jsFunc = self.jsContext[@&quot;jsFunc&quot;];</span><br><span class="line"> [jsFunc callWithArguments:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jsCallObjcAndObjcCallJsWithDict:(NSDictionary *)params &#123;</span><br><span class="line"> NSLog(@&quot;jsCallObjcAndObjcCallJsWithDict was called, params is %@&quot;, params);</span><br><span class="line"></span><br><span class="line"> // 调用JS的方法</span><br><span class="line"> JSValue *jsParamFunc = self.jsContext[@&quot;jsParamFunc&quot;];</span><br><span class="line"> [jsParamFunc callWithArguments:@[@&#123;@&quot;age&quot;: @10, @&quot;name&quot;: @&quot;lili&quot;, @&quot;height&quot;: @158&#125;]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定参数的用法</span><br><span class="line">// 在JS中调用时，函数名应该为showAlertMsg(arg1, arg2)</span><br><span class="line">- (void)showAlert:(NSString *)title msg:(NSString *)msg &#123;</span><br><span class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   UIAlertView *a = [[UIAlertView alloc] initWithTitle:title message:msg delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil];</span><br><span class="line">   [a show];</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="JavaScriptCore使用注意"><a href="#JavaScriptCore使用注意" class="headerlink" title="JavaScriptCore使用注意"></a>JavaScriptCore使用注意</h2><p>JavaScript调用本地方法是在子线程中执行的，这里要根据实际情况考虑线程之间的切换。</p>
<p>模型实现完了，在哪里注入呢。在controller的webView加载完成后<br>我们是通过webView的valueForKeyPath获取的，其路径为documentView.webView.mainFrame.javaScriptContext。<br>这样就可以获取到JS的context，然后为这个context注入我们的模型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIWebViewDelegate</span><br><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView </span><br><span class="line">&#123;</span><br><span class="line"> self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">  // 通过模型调用方法，这种方式更好些。</span><br><span class="line">  HYBJsObjCModel *model  = [[HYBJsObjCModel alloc] init];</span><br><span class="line">  // 模型</span><br><span class="line">  self.jsContext[@&quot;OCModel&quot;] = model;</span><br><span class="line">  model.jsContext = self.jsContext;</span><br><span class="line">  model.webView = self.webView;</span><br><span class="line">  // 增加异常的处理</span><br><span class="line">  self.jsContext.exceptionHandler = ^(JSContext *context,   </span><br><span class="line"> JSValue *exceptionValue) &#123;</span><br><span class="line">    context.exception = exceptionValue;</span><br><span class="line">    NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外关于模型，也可根据需求直接将模型作为controller，去实现相关的方法实现，省去模型这一层。 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIWebViewDelegate</span><br><span class="line"></span><br><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView </span><br><span class="line">&#123;</span><br><span class="line">  self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; </span><br><span class="line">  self.jsContext[@&quot;OCModel&quot;] = self; </span><br><span class="line">  self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">  context.exception = exceptionValue; </span><br><span class="line">  NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">     &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;div style=&quot;margin-top: 100px&quot;&gt; </span><br><span class="line">        &lt;h1&gt;Objective-C和JavaScript交互的那些事&lt;/h1&gt; </span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;CallCamera&quot; onclick=&quot;OCModel.callCamera()&quot;&gt; </span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">       &lt;div&gt;</span><br><span class="line">         &lt;input type=&quot;button&quot; value=&quot;Share&quot; onclick=&quot;callShare()&quot;&gt; </span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">       var callShare = function() &#123; </span><br><span class="line">          var shareInfo = JSON.stringify(&#123;&quot;title&quot;: &quot;标题&quot;, &quot;desc&quot;: &quot;内容&quot;, &quot;shareUrl&quot;: &quot;http://www.jianshu.com/p/f896d73c670a&quot;, </span><br><span class="line">          &quot;shareIco&quot;:&quot;http://upload-images.jianshu.io/upload_images/1192353-fd26211d54aea8a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;&#125;); </span><br><span class="line">          OCModel.share(shareInfo);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       var picCallback = function(photos) &#123;</span><br><span class="line">       alert(photos);</span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">       var shareCallback = function()&#123;</span><br><span class="line">       alert(&apos;success&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>以上就是简单的利用JavaScriptCore framework进行JS交互的用法，</p>
<h1 id="2-WebViewJavascriptBridge"><a href="#2-WebViewJavascriptBridge" class="headerlink" title="2. WebViewJavascriptBridge"></a>2. WebViewJavascriptBridge</h1><p>这个第三方库起先是在UIWebView与JS的深度交互大神文中知悉。其还是使用拦截WebView请求方法，但是做了完整的封装后，使用起来还是很简单的。</p>
<p>1) 导入</p>
<p><code>#import &quot;WKWebViewJavascriptBridge.h&quot;</code></p>
<p>2) 初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</span><br><span class="line">// 开启日志，方便调试</span><br><span class="line">[WebViewJavascriptBridge enableLogging];</span><br><span class="line">3) Web端setupWebViewJavascriptBridge</span><br><span class="line"></span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">window.WVJBCallbacks = [callback];</span><br><span class="line">var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</span><br><span class="line">document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">4)call setupWebViewJavascriptBridge</span><br><span class="line"></span><br><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line"></span><br><span class="line">/* Initialize your app here */</span><br><span class="line"></span><br><span class="line">bridge.registerHandler(&apos;JS Echo&apos;, function(data, responseCallback) &#123;</span><br><span class="line">    console.log(&quot;JS Echo called with:&quot;, data)</span><br><span class="line">    responseCallback(data)</span><br><span class="line">&#125;)</span><br><span class="line">bridge.callHandler(&apos;ObjC Echo&apos;, function responseCallback(responseData) &#123;</span><br><span class="line">    console.log(&quot;JS received response:&quot;, responseData)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>OC端初始化时 默认消息处理器</p>
<p>实例化WebViewJavascriptBridge并定义native端的默认消息处理器。</p>
<p>JS调用bridge.send()即可触发默认处理。</p>
<pre><code>_bridge = [WebViewJavascriptBridge bridgeForWebView:webView handler:^(id data, WVJBResponse *response) {  
    NSLog(@&quot;ObjC received message from JS: %@&quot;, data);  
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;ObjC got message from Javascript:&quot; message:data delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil];  
    [alert show];  
}];
</code></pre><p>OC端调用[self.bridge send];即可触发JS端的默认处理。</p>
<pre><code>[self.bridge send:@&quot;Give me a response, will you?&quot; responseCallback:^(id responseData) {
NSLog(@&quot;ObjC got its response! %@&quot;, responseData);
}];
</code></pre><p>OC端registerHandler接收JS调用</p>
<p>在JS中调用了bridge.callHandler(‘getScreenHeight’)就会触发OC注册的对应的handler，responseCallback中回调JS传递参数</p>
<pre><code>[self.bridge registerHandler:@&quot;getScreenHeight&quot; handler:^(id data, WVJBResponseCallback responseCallback) {
  NSLog(@&quot;ObjC Echo called with: %@&quot;, data);
  responseCallback([NSNumber numberWithInt:[UIScreen              
  mainScreen].bounds.size.height]);
}];
</code></pre><p>或者 JS传递data给OC，OC打印</p>
<pre><code>[self.bridge registerHandler:@&quot;log&quot; handler:^(id data, WVJBResponseCallback responseCallback) {
NSLog(@&quot;Log: %@&quot;, data);
}];
</code></pre><p>OC端callHandler调用JS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">调用JS showAlert，传递data</span><br><span class="line"></span><br><span class="line">[self.bridge callHandler:@&quot;showAlert&quot; data:@&quot;Hi from ObjC to JS!&quot;];</span><br><span class="line">调用JS getCurrentPageUrl，在block中获取参数</span><br><span class="line"></span><br><span class="line">[self.bridge callHandler:@&quot;getCurrentPageUrl&quot; data:nil responseCallback:^(id responseData) &#123;</span><br><span class="line">    NSLog(@&quot;Current UIWebView page URL is: %@&quot;, responseData);</span><br><span class="line">&#125;];</span><br><span class="line">还可设置代理监听</span><br><span class="line"></span><br><span class="line">[bridge setWebViewDelegate:(UIWebViewDelegate*)webViewDelegate];</span><br><span class="line">JS registerHandler接收OC调用</span><br><span class="line"></span><br><span class="line">注册handle，OC可以通过[bridge callHandler:&quot;handlerName&quot; data:@&quot;Foo&quot;] 和 [bridge callHandler:&quot;handlerName&quot; data:@&quot;Foo&quot; responseCallback:^(id responseData) &#123; ... &#125;]进行调用JS</span><br><span class="line"></span><br><span class="line">OC传递data进行调用</span><br><span class="line"></span><br><span class="line">bridge.registerHandler(&quot;showAlert&quot;, function(data) &#123; alert(data) &#125;)</span><br><span class="line">参数结果回传给OC</span><br><span class="line"></span><br><span class="line">bridge.registerHandler(&quot;getCurrentPageUrl&quot;, function(data, responseCallback) &#123;</span><br><span class="line">responseCallback(document.location.toString())</span><br><span class="line">&#125;)</span><br><span class="line">bridge.callHandler(&quot;handlerName&quot;, data)</span><br><span class="line">JS 调用OC</span><br><span class="line"></span><br><span class="line">JS调用bridge.callHandler(&quot;handlerName&quot;, data)和bridge.callHandler(&quot;handlerName&quot;, data, function responseCallback(responseData) &#123; ... &#125;)</span><br></pre></td></tr></table></figure>
<p>调用OC端打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bridge.callHandler(&quot;Log&quot;, &quot;Foo&quot;)</span><br><span class="line">调用OC端获取高度，在block中使用</span><br><span class="line"></span><br><span class="line">bridge.callHandler(&quot;getScreenHeight&quot;, null, function(response) &#123;</span><br><span class="line">alert(&apos;Screen height:&apos; + response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="3-WKWebView-iOS8-or-Later"><a href="#3-WKWebView-iOS8-or-Later" class="headerlink" title="3.WKWebView - iOS8 or Later"></a>3.WKWebView - iOS8 or Later</h1><p>iOS8，苹果新推出了WebKit，用WKWebView代替UIWebView和WebView。相关的使用和特性可以细读。<br>WKWeb​View<br>iOS 8 WebKit框架概览（下）<br>WKWebView特性及使用</p>
<h2 id="WKWebView新特性"><a href="#WKWebView新特性" class="headerlink" title="WKWebView新特性"></a>WKWebView新特性</h2><p>性能、稳定性、功能大幅度提升<br>允许JavaScript的Nitro库加载并使用（UIWebView中限制）<br>支持了更多的HTML5特性<br>高达60fps的滚动刷新率以及内置手势<br>GPU硬件加速<br>KVO<br>重构UIWebView成14类与3个协议，查看官方文档</p>
<p>需要注意的是WKWebView貌似不支持NSURLProtocol和NSURLCache。不能做缓存的话，就蛋疼了。</p>
<p>关于WKWebView的代理方法 这篇有比较完整的介绍<br><a href="http://www.jianshu.com/p/1d7a8525ad16" target="_blank" rel="external">http://www.jianshu.com/p/1d7a8525ad16</a></p>
<p>下面是相关的交互方法</p>
<p>WKWebView调用js方法和UIWebView类似，一个是evaluateJavaScript，一个是stringByEvaluatingJavaScriptFromString。获取返回值的方式不同，WKWebView用的是回叫函数获取返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> //直接调用js</span><br><span class="line">    webView.evaluateJavaScript(&quot;hi()&quot;, completionHandler: nil)</span><br><span class="line">//调用js带参数</span><br><span class="line">    webView.evaluateJavaScript(&quot;hello(&apos;liuyanwei&apos;)&quot;, completionHandler: nil)</span><br><span class="line">// 调用js获取返回值</span><br><span class="line">   webView.evaluateJavaScript(&quot;getName()&quot;) &#123; (any,error) -&gt; Void in</span><br><span class="line">        NSLog(&quot;%@&quot;, any as! String)</span><br><span class="line">    &#125;</span><br><span class="line">UIwebView没有js调app的方法，而在WKWebView中有了改进。具体步骤分为app注册handler，app处理handler委托，js调用三个步骤</span><br><span class="line"></span><br><span class="line">注册handler需要在webView初始化之前，如示例，注册了一个webViewApp的handler</span><br><span class="line">     config = WKWebViewConfiguration()</span><br><span class="line">      //注册js方法</span><br><span class="line">     config.userContentController.addScriptMessageHandler(self, name: &quot;webViewApp&quot;)</span><br><span class="line">      // 初始化</span><br><span class="line">     webView = WKWebView(frame: self.webWrap.frame, configuration: config)</span><br><span class="line">处理handler委托。ViewController实现WKScriptMessageHandler委托的func userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage)代理方法。在里面处理事件。</span><br><span class="line">     //实现WKScriptMessageHandler委托</span><br><span class="line">     class ViewController：WKScriptMessageHandler</span><br><span class="line">     //实现js调用ios的handle委托</span><br><span class="line">     func userContentController(userContentController: WKUserContentController, didReceiveScriptMessage message: WKScriptMessage) &#123;</span><br><span class="line">     //接受传过来的消息从而决定app调用的方法</span><br><span class="line">      let dict = message.body as! Dictionary&lt;String,String&gt;</span><br><span class="line">      let method:String = dict[&quot;method&quot;]!</span><br><span class="line">      let param1:String = dict[&quot;param1&quot;]!</span><br><span class="line">      if method==&quot;hello&quot;&#123;</span><br><span class="line">          hello(param1)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>js调用 。通过window.webkit.messageHandlers.webViewApp找到之前注册的handler对象，然后调用postMessage方法把数据传到app，app通过上一步的方法解析方法名和参数。webViewApp是之前注册的name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message = &#123;</span><br><span class="line">                &apos;method&apos; : &apos;hello&apos;,</span><br><span class="line">                &apos;param1&apos; : &apos;liuyanwei&apos;,</span><br><span class="line">                &#125;;</span><br><span class="line">window.webkit.messageHandlers.webViewApp.postMessage(message);</span><br></pre></td></tr></table></figure>
<p>如果需要app对js的调用有所响应，可以通过回叫函数的方式回应js。可以在调用app的时候增加一个js回叫函数名 ,app在处理完之后可以呼叫回叫函数并把需要的参数通过回叫函数的方式进行传递</p>
<p>WKUserScript 允许在正文加载之前或之后注入到页面中。这个强大的功能允许在页面中以安全且唯一的方式操作网页内容。</p>
<p>一个简单的例子如下，用户改变背景的用户脚本被插入到网页中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let source = &quot;document.body.style.background = \&quot;#777\&quot;;&quot;</span><br><span class="line">let userScript = WKUserScript(source: source,     injectionTime: .AtDocumentEnd, forMainFrameOnly: true)</span><br><span class="line"></span><br><span class="line">let userContentController = WKUserContentController()</span><br><span class="line">userContentController.addUserScript(userScript)</span><br><span class="line"></span><br><span class="line">let configuration = WKWebViewConfiguration()</span><br><span class="line">configuration.userContentController = userContentController</span><br><span class="line">self.webView = WKWebView(frame: self.view.bounds, configuration: configuration)</span><br></pre></td></tr></table></figure>
<p>WKUserScript 对象可以以 JavaScript 源码形式初始化，初始化时还可以传入是在加载之前还是结束时注入，以及脚本影响的是这个布局还是仅主要布局。于是用户脚本被加入到 WKUserContentController 中，并且以 WKWebViewConfiguration 属性传入到 WKWebView 的初始化过程中。</p>
<h1 id="4-拦截协议"><a href="#4-拦截协议" class="headerlink" title="4. 拦截协议"></a>4. 拦截协议</h1><p>最简单也是最容易想到的一种<br>UIWebView的代理方法，web view发出请求后拦截，查看是否为约定的协议，采取处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = request.URL.absoluteString;</span><br><span class="line">    if ([url rangeOfString:@&quot;camera://&quot;].location != NSNotFound) &#123;</span><br><span class="line">        // url的协议头是camera</span><br><span class="line">        NSLog(@&quot;callCamera&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">WKWebView</span><br><span class="line"></span><br><span class="line">-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = navigationAction.request.URL.absoluteString;</span><br><span class="line">    NSLog(@&quot;%@&quot;,url);</span><br><span class="line"></span><br><span class="line">    if (navigationAction.navigationType == WKNavigationTypeLinkActivated  &amp;&amp; [url rangeOfString:@&quot;camera://&quot;].location != NSNotFound)</span><br><span class="line">    &#123;</span><br><span class="line">        // url的协议头是camera</span><br><span class="line">        NSLog(@&quot;callCamera&quot;);</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line"></span><br><span class="line">        // dosomthing。。。</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-NSURLProtocol拦截"><a href="#5-NSURLProtocol拦截" class="headerlink" title="5. NSURLProtocol拦截"></a>5. NSURLProtocol拦截</h1><p>这种方式也是最近才看到，原本利用自定义NSURLProtocol来做缓存处理。相关的文章可以看：<br>NSURLProtocol和NSRunLoop的那些坑<br>iOS中的 NSURLProtocol</p>
<p>在自定义的Protocol的<code>- (void)startLoading</code>方法中，可以拦截到请求。一般会在这里做缓存的判断与读取处理。在此处，也可以判断约定的协议，然后发送通知，客户端就可以接收到通知，执行相应的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLoading</span><br><span class="line">&#123;</span><br><span class="line">    NSString * url = [[[self request] URL] absoluteString];</span><br><span class="line"></span><br><span class="line">    if([url hasPrefix:@&quot;LocalActions/&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        NSString * actname = [url stringByReplacingOccurrencesOfString:@&quot;LocalActions/&quot; withString:@&quot;LocalAction_&quot;];</span><br><span class="line"></span><br><span class="line">        // 发送通知  客户端就可执行方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:actname object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/06/人脸检测/" class="prev">上一篇</a><a href="/2017/01/18/仿写Keep登录页/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">iAlexSun</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>