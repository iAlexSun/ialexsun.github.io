<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 离屏渲染的性能优化 · iAlexSun's</title><meta name="description" content="离屏渲染的性能优化 - iAlexSun"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="iAlexSun's"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="http://ac-pqj923nc.clouddn.com/0aac0dce4f2eff61dbe0.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/iAlexSun" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">离屏渲染的性能优化</h1><div class="post-info">Aug 11, 2016</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>圆角设置大家一定都会使用,一行两行代码就会搞定,但是你真的认为设置圆角就这么简单吗？如果你的程序圆角数量只有几个的时候你可能感觉不到这个掉帧杀手的存在,What? 你会问,我用了这么久的圆角都没有掉帧的情况,你在逗我？的确,数量少的圆角不会带来离屏渲染导致掉帧的问题,但是你是否有过20，30，40….或者更多的圆角呢？如果有过你一定知道带来的后果,废话少说,切入正题。</p>
<h1 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h1><hr>
<p>OpenGL中，GPU屏幕渲染有以下两种方式： On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 创建新缓冲区 要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换 离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；</p>
<p>等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 哪些行为会导致Offscreen rendering?(这些只是官方语言,就是告诉你离屏渲染是怎么回事，不理解的话接着往下看),其实官方早在2011年的WWDC上就提到了离屏渲染的效果<a href="https://developer.apple.com/videos/play/wwdc2011/121/" target="_blank" rel="external">WWDC 2011: Understanding UIKit Rendering </a>.</p>
<p><img src="http://ac-mcm5vzvc.clouddn.com/8db566ed88484924.png" alt=""></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2014/419/" target="_blank" rel="external">WWDC 2014: Advanced Graphics and Animations for iOS Apps</a>演示了「Color Offscreen-Renderd Yellow」这个工具的使用!本文主要是为了总结有几种优化方式和背后的原理!</p>
<h1 id="设置圆角带来的问题"><a href="#设置圆角带来的问题" class="headerlink" title="设置圆角带来的问题"></a>设置圆角带来的问题</h1><hr>
<p><code>view.layer.cornerRadius = 5</code>你可能会问平时就是这么写的,还有<br><code>view.layer.masksToBounds = YES;</code>一起写的,确实文章开头就提到少量的设置圆角不会产生掉帧的问题。让我们测试一下果然出现了我们想要的性能损耗(并不是幸灾乐祸哦)<img src="http://ac-mcm5vzvc.clouddn.com/eec6379187bc5188.png" alt="">,</p>
<h2 id="重新绘制方案"><a href="#重新绘制方案" class="headerlink" title="重新绘制方案:"></a>重新绘制方案:</h2><p>网上有很多的方法是通过 Core Graphics 画出圆角,实际重新绘制会出现新的问题。</p>
<ul>
<li>1.绘制后把圆角缓存在磁盘里，第二次加载直接使用缓存的圆角图像。</li>
<li>2.直接保存在内存中,内存不足的情况下好像不是最好的方案!圆角使用UIImageView来处理。</li>
</ul>
<p>简单来说，底层铺一个UIImageView,然后用GraphicsContext生成一张带圆角的图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIImage (RoundedCorner)</span><br><span class="line"></span><br><span class="line">- (UIImage *)yal_imageWithRoundedCornersAndSize:(CGSize)sizeToFit andCornerRadius:(CGFloat)radius</span><br><span class="line">&#123;</span><br><span class="line">    CGRect rect = (CGRect)&#123;0.f, 0.f, sizeToFit&#125;;</span><br><span class="line"></span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(sizeToFit, NO, UIScreen.mainScreen.scale);</span><br><span class="line">    CGContextAddPath(UIGraphicsGetCurrentContext(),</span><br><span class="line">                     [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</span><br><span class="line">    CGContextClip(UIGraphicsGetCurrentContext());</span><br><span class="line"></span><br><span class="line">    [self drawInRect:rect];</span><br><span class="line">    UIImage *output = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line"></span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>原理其实就是利用 Core Graphics 自己画出了一个圆角矩形.还有的小伙伴把这个过程封装了起来，如果你喜欢这种方式也可以使用封装好的这种方式<a href="https://github.com/raozhizhen/JMRoundedCorner" target="_blank" rel="external">JMRoundedCorner</a>可以下载研究一下原理，个人认为大部分情况下可以使用这种方案来使用!</p>
<h1 id="混合图层方案："><a href="#混合图层方案：" class="headerlink" title="混合图层方案："></a>混合图层方案：</h1><p>在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡。实际中有这种需求的基本是制造圆形头像，普通的圆角遮罩需要这种，如果叠加的视图都一样，可以只加载一次遮罩图片以减少内存占用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CAShapeLayer *layer = [CAShapeLayer layer];  </span><br><span class="line">UIBezierPath *aPath = [UIBezierPath bezierPathWithOvalInRect:aImageView.bounds];  </span><br><span class="line">layer.path = aPath.CGPath;  </span><br><span class="line">aImageView.layer.mask = layer;</span><br></pre></td></tr></table></figure>
<p>这种方案同样也有小伙伴封装好了的方案<a href="https://gist.github.com/seedante" target="_blank" rel="external">Draw a transparent image</a>在一个设置<code>opaque = false的 CGContext</code>里，设定填充颜色然后用两条贝塞尔曲线围成一个封闭区域，最后从这个绘制环境导出图像即可。</p>
<h1 id="Rasterization方案"><a href="#Rasterization方案" class="headerlink" title="Rasterization方案:"></a>Rasterization方案:</h1><p>离屏渲染本来是个优化设计，如何物尽其用?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.layer.shouldRasterize = true</span><br><span class="line">cell.layer.rasterizationScale = cell.layer.contentsScale</span><br></pre></td></tr></table></figure>
<p>如果视图内容是动态变化的，使用 Rasterization 有可能让性能变得更糟。什么情况下会遇到动态内容的视图呢，能想到的只有后台下载图片完毕后切换到主线程设置这种了。<br><img src="http://ac-mcm5vzvc.clouddn.com/8262934ab7ba3e5e.png" alt=""><br>从结果来看，开启 Rasterization 后 GPU 的利用率始终不高，如果 CPU 的利用率控制得当的话 FPS 不会难看，比预计的性能要好多了。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><hr>
<p>Rasterization：适用于静态内容的视图，也就是内部结构和内容不发生变化的视图，对上面的所有效果而言，在实现成本以及性能上最均衡的。即使是动态变化的视图，开启 Rasterization 后能够有效降低 GPU 的负荷，不过在动态视图里是否启用还是看 Instruments 的数据。</p>
<p>规避离屏渲染:用其他手法来模拟效果，混合图层是个性能最好、耗能最少的通用优化方案，尤其对于 rounded corer 和 mask。</p>
<p>建议大家还是采取预先生成圆角图片，并缓存起来这个方法才是比较好的手段。预处理圆角图片可以在后台处理，处理完毕后缓存起来，再在主线程显示，这就避免了不必要的离屏渲染了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><hr>
<p><a href="http://www.reviewcode.cn/article.html?reviewId=7" target="_blank" rel="external">关于性能的一些问题</a></p>
<p><a href="http://blog.raozhizhen.com/post/uiviewshe-zhi-bu-hong-fa-chi-ping-xuan-ran-de-yuan-jiao" target="_blank" rel="external">UIView设置不触发离屏渲染的圆角</a></p>
<p><a href="https://bestswifter.com/efficient-rounded-corner" target="_blank" rel="external">iOS 高效添加圆角效果实战讲解</a></p>
<p><a href="http://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="external">离屏渲染优化详解：实例示范+性能测试</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/08/14/内存管理--ARC/" class="prev">PREV</a><a href="/2016/07/24/深入浅出了解Runloop/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">iAlexSun</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>